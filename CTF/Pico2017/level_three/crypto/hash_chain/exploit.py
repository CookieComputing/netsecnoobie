#!/usr/bin/python2
import md5 
from pwn import *
import time

LIMIT = 500
TARGET = "shell2017.picoctf.com"
PORT = 46290
FILE = "hash.txt"

def generate_hashes(seed):
    a = []
    current_hash = seed
    
    for i in range(1000): 
        current_hash = md5.new(current_hash).hexdigest()
        a.append(current_hash)
    
    return a

def find_prev_hash(array,current_hash):
    return array[array.index(current_hash)-1]

def skip_intro(conn):
    for i in range(6):
        conn.recvline()

def skip_question(conn):
    for i in range(4):
        conn.recvline()

def go_to_register(conn):
    #there's a bunch of crap that needs to be skipped for recvline()
    skip_intro(conn)
    skip_question(conn)
    conn.sendline("r")
     
def extract_hash_id():
    conn = remote(TARGET,PORT) 
    go_to_register(conn)
    
    id_and_seed = conn.recvline().split()
    hash_id = id_and_seed[7].rstrip('\n')
    seed = id_and_seed[-1].rstrip('\n')

    conn.recvline()
    current_hash = conn.recvline().rstrip('\n')
    
    prev_hash = find_prev_hash(generate_hashes(seed),current_hash)
    conn.sendline(prev_hash)
    
    #Yep is in the validated hash, so we will use this as the success metric
    if "Yep!" in conn.recvline():
        conn.close()
        return (hash_id, seed)
    conn.close()
    return None
         
def main(): 
    hash_list = []
    for i in range(1000):
        try:
            hash_list.append(extract_hash_id())
        except:
            time.sleep(1)
            continue
    with open("hash.txt","a") as fp:
        for tup in hash_list:
            fp.write("{} {}\n".format(tup[0],tup[1])) 

    #I went back into the code to use this function whenever I found a match in my hash text file
   # print(find_prev_hash(generate_hashes("ead81fe8cfe9fda9e4c2093e17e4d024"),"58cb392a127b699c6f22f228e23ae73e"))
    
if __name__ == "__main__":
    main()
